数理最適化特論 レポート２回目
===

###### tags: `数理最適化特論`

>   情報理工学系研究科 創造情報学専攻 修士2年 48-216622 秀島宇音
>   2022年 8月 4日

## 紹介する最適化問題

次に引用する研究より。

>   Jingjing, W. and Magdalena B.: Elastic Memory Management for Cloud Data Analytics, *2017 USENIX Annual Technical Conference*, USENIX Association, pp. 745--758, available [online](https://www.usenix.org/conference/atc17/technical-sessions/presentation/wang) (2017).

計算資源クラウドなどの、1つのマシンで複数のアプリケーションを動かす場面における、メモリ管理に関する問題。前提として、以下のようなアプリケーションの実行と使えるメモリ資源量の関係について、一般に以下のことが言える。

*   使うメモリ資源はOSに要求して提供させたり返したりする。この処理は重いので、一時的に使わなくなっても直ぐには返さない。
*   最低限必要なだけメモリ資源が与えられなければ、アプリケーションは実行できない(killされる他ない)。
*   より多くのメモリ資源が与えられたほうが高速に動く。しかし速度の伸びは逓減していく。

これを踏まえ、管理対象のアプリケーションに対して、下に列挙する働きかけの内どれをすることが全体の実行性能を最も高めるのかを考えるのが、紹介する問題である。

*   メモリ資源を追加で使うことを許す
*   使っていないメモリ資源をかき集め、返却させる
*   メモリ資源の余裕ができるまで、実行を止めて待機させる
*   実行を断念する(killする)

Jingjingらは、これをナップサック問題として定式化した。すなわち、アプリケーションを「荷物」と、働きかけを「積み方」とし、どのアプリケーションをどう積むかによって「重さ」や運べる「価値」が変わるとモデル化したのである。ここでの「重さ」としては働きかけ後のメモリ使用量を採用し、マシン内で使えるメモリ資源を使用量の総和が越えない範囲で最適化するようにする。最適化する「価値」については、次のような全順序関係を規定する。

1.  killするアプリケーションが少ない方が価値が高い。同数の場合は、
2.  待機させるアプリケーションが少ない方が価値が高い。これも同数の場合は、
3.  各アプリケーションの $\small \displaystyle \frac{\text{働きかけに応える所要時間}}{\text{メモリ使用量の変化量の絶対値}}$の総和が小さいほうが価値が高い。

なお、「価値」の加算は上の比較演算で登場するプロパティそれぞれの和で定義される。


## 解法

管理するアプリケーション(荷物)が有限個であり、働きかけ(積み方)の種類も有限である。メモリ資源の量(重さ)として取りうる値も、マシン内で使える量に限定すれば有限通りである。このようなナップサック問題は0-1ナップサック問題と呼ばれ、比較的高速に解ける。

具体的には、「重さ」が取りうる値の種類を$\mathcal{W}$、「荷物」の数を$B$、「積み方」の種類を$L$として、次のようなアルゴリズムによって **$O(\mathcal{W}BL)$の時間で解ける**。

:::info
「重さ」が取りうる値の集合を$W$、「荷物」を$\{b_i\}_{i=0}^{B-1}$、「積み方」を$\{l_j\}_{j=0}^{L-1}$、「価値」の取りうる値の集合を$V$とする。「荷物」$b$を「積み方」$l$で運んだ際の「重さ」を$f_W(b, l)$、「価値」を$f_V(b, l)$で得られるとする。

1.  $S_0 \gets \{0 \mapsto 0 \} \in (W \to V)$
2.  $i \in [0, B)$のそれぞれについて次を実行する
    1.  $S_{i+1} \gets S_i$
    2.  $((w \to v), j) \in S_i \times [0, L)$のそれぞれについて次のどれかを実行する。ただし$w' := w + f_W(b_i, l_j),$ $v' = v + f_L(b_i, l_j)$とする。
        *   $w' \notin \mathrm{dom}(S_{i+1})$ならば、$S_{i+1} \gets S_{i+1} \cup \{ w' \mapsto v' \}$
        *   $w' \in \mathrm{dom}(S_{i+1})$かつ$S_{i+1}(w') < v'$ならば、$S_{i+1} \gets (S_{i+1} \setminus \{ w' \mapsto S_{i+1}(w') \}) \cup \{ w' \mapsto v' \}$
        *   $w' \in \mathrm{dom}(S_{i+1})$かつ$S_{i+1}(w') \geq v'$ならば、何もしない
3.  $\max \mathrm{codom}(S_B)$を達成しうる最高の「価値」とする。(それを得る「荷物」と「積み方」は$\{S_k\}_{k=0}^B$の情報を用いて算出できる)
:::

### 計算量解析

収束性に代えて、アルゴリズムの正しさの鍵となる部分$S_k$について簡単に述べる。$k = 1, \dots, B$のそれぞれについて、$\mathrm{dom}(S_k)$は、「荷物」$\{b_i\}_{i=0}^{k-1}$を様々な「積み方」で運んだ際の「重さ」の和として取りうる値全体の集合になる。そして$S_k$は、そうした「重さ」をピッタリ使って運べる「価値」の最大値になる。そのために、「$S_{i+1}(w') \geq v'$ならば、何もしない」のように「価値」の高い方を残すような条件分岐をしている。また、$S_i$を基に$S_{i+1}$を算出する構造はこの性質を利用している。

このアルゴリズムでは、厳密な最適解の1つを得るために$O(\mathcal{W}BL)$の時間を要する。特に重要なのは、オーダが$\mathcal{W}$や$L$の一次関数になっていること、すなわち取りうる「重さ」や「積み方」の全てについて処理を繰り返すというコストを払っていることである。「重さ」の制約をきめ細やかに満たそうとしたり、「積み方」の種類が多いか無限であったりすると現実的な計算量ではなくなる。実際、引用した研究では、「重さ」にあたるメモリ使用量の管理単位を状況に応じて粗くするなどの工夫をしている。


## 補足: 分野の背景

私が研究しているのはプログラミング(言語)で、その中でもメモリ資源の様々な使い方を扱うプログラミングを主な対象としている。そこでは、メモリ使用量や実行時間を最小化しようとするなど「最適化」を志向することは少なくない。

ただし、実行可能解の集合が「全てのプログラムの集合」のような広大で扱いにくいものであり、目的関数にあたるプログラムからメモリ使用量や実行時間への写像もブラックボックスである。停止性問題を踏まえれば、目的関数は計算不能にもなりうると分かる。

このような分野の特性もあり、授業で扱ったような連続最適化の例は見つけられなかった。それどころか、数理最適化アルゴリズムを適用する例もほぼ見つけられなかった。（むしろ、ヒューリスティックを利用して「こういうプログラムで上手くいく」を実現するのが主流である。）

このレポートで紹介した最適化問題は、メモリ管理を題材としながらも数理最適化問題として扱えるように抽象化している、稀有な例である。

これは個人的な考えだが、その結果としてナップサック問題に定式化されたことは自然な結果だと思う。なぜなら、目的関数の値域が複雑で距離が定義できなくても、全順序さえ定義されれば適用できるからである。
